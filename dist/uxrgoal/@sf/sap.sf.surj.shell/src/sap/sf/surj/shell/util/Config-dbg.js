    /**
     * This function will normalize an incoming options object by updating any
     * default values, and validating the required attributes and their types.
     * 
     * <h3>Validation</h3>
     * 
     * Validation is always optional, but you can add this validation of output
     * options object to ensure that users are not incorrectly calling your
     * component.
     * 
     * Not only will this provide a more verbose error for users of your
     * component facilitating quick error recovery, it will also serve to better
     * document the contract between the component and the parent controller.
     * 
     * Values contained in the validation object is expected to be one of the
     * following:
     * 
     * <ul>
     * <li>Array: List of different possible types for the value.</li>
     * <li>ArrayType: The value must be an array, and every value in that array
     * must match the sub type. Use <code>util.Config.arrayType(subType)</code>
     * to generate an object of type ArrayType. (recursive)</li>
     * <li>EnumType: The value must exactly match one of a given set of values.
     * Use <code>util.Config.enumType(...)</code> to generate an object of
     * type EnumType.</li>
     * <li>Config.ValidatorType: You can create your own object that
     * extends this object. Here is an example.
     * <code>extend(CustomValidator, Config.ValidatorType, {validate: function(value,errors){}});</code></li>
     * <li>function: The value can be an instanceof this constructor.</li>
     * <li>Object: The value can be an object which matches the rules defined
     * in this object.</li>
     * <li>null: The value can be null.</li>
     * <li>"undefined": The value can be undefined.</li>
     * <li>"string": The value can be a non-empty string.</li>
     * <li>"number": The value can be a number.</li>
     * <li>"object": The value can be a non-null object.</li>
     * <li>"*": The value can be anything, but not null or undefined.</li>
     * </ul>
     * 
     * <h3>Validation Errors</h3>
     * 
     * Any time there is a validation error. The error will result in an
     * exception with a generic message. However, the Logger will be used to
     * display each individual message that went wrong before the error is
     * thrown.
     * 
     * <h3>Return Object</h3>
     * 
     * The return object from this function will be an object, but there is one
     * extra feature. You can test that object to see if it was truly created by
     * this function by checking if it is an instanceof Config.
     * 
     * This is a little different, because in your code you do not invoke new
     * Config, you will call it like a function, like so:
     * 
     * <pre>
     * var result = Config(null, {hello:"world"});
     * assert(result.hello === "world", "This assertion will pass");
     * assert(result instanceof Config, "This will also pass");
     * </pre>
     * 
     * @constructor
     * @param {Object} options The incoming options object sent by the user of
     *            the Component's constructor.
     * @param {Object=} defaults Optional defaults object. The keys for this
     *            object will correspond to the keys in the options object. If
     *            there is some key in defaults in which the value from the
     *            options object was undefined, the output from this function
     *            will have an object with the value set from the defaults
     *            object.
     * @param {Object=} validation Optional validation object. The keys for this
     *            object will correspond to the keys in the options object, and
     *            the value will be used to determine if the value on the
     *            resulting object is valid. If one of the rules defined in the
     *            validation was determined to be false, then there will be an
     *            assertion error. See the description of this function for more
     *            information about how to structure the values of this object
     *            to properly validate objects.
     * @return {Config} An Object which contains all the config attributes
     *         set, and you can test that this object was generated by this
     *         function by testing <code>result instanceof Config</code>
     */
sap.ui.define('sap/sf/surj/shell/util/Config', [
        'jquery.sap.global',
        'sap/sf/surj/shell/util/Logger'
    ], function($, Logger) {

    var pkg = 'sap.sf.surj.shell.util';
    var util = $.sap.getObject(pkg);

    var Config = util.Config = function(options, defaults, validation) {
        var config = set({}, options || {});
        if (defaults) {
            for ( var attribute in defaults) {
                if (!options || typeof options[attribute] == 'undefined') {
                    config[attribute] = defaults[attribute];
                }
            }
        }
        if (validation) {
            var errors = [];
            if (!Config.validate(config, validation, errors)) {
                errors.forEach(function(err) {
                    Logger.error.apply(Logger, err);
                });
                assert(false, 'Config: There was at least one error');
            }
        }
        set(this, config);
    };

    /**
     * You can use this to convert a legacy argument list to an options object
     * to convert to a options object with named attributes. You can call this
     * with either the normal options/config object as a single argument, or the
     * list of multiple arguments from the previous argument list.
     * 
     * This will tell the difference between the 2 argument lists, and return
     * the correctly formatted config object for either case.
     * 
     * If the old argument list can support a single argument, you MUST make
     * sure that the validation can be used to differentiate between the 2
     * situations - either a single argument in the old argument list, or an
     * options object.
     * 
     * You can accomplish this by enforcing that the first argument be a
     * specific type (like string, number, or juic.Component). If the first
     * argument can be an object which also matches validation, then this
     * function will throw an error.
     * 
     * @see Config
     * @param {arguments} args The arguments to convert
     * @param {Array.<string>} oldArguments The corresponding attribute names
     *            for the defined argument list
     * @param {Object=} defaults The defaults (see Config)
     * @param {Object=} validation The validation (see Config)
     * @throws Error If there was exactly one argument which couldn't be
     *             determined to be an argument list or an options object
     */
    Config.convertArguments = function(args, oldArguments, defaults, validation) {
        /*
         * Generate an options object for the arguments assuming that we are
         * using the oldArguments list.
         */
        var options = {};
        oldArguments.forEach(function(arg, idx) {
            options[arg] = args[idx];
        });

        /*
         * The situation becomes complicated when there is only one argument
         * passed in. It is for this reason you must provide good enough
         * validation.
         */
        if (args.length == 1 && args[0] != null) {
            var first = args[0];
            if (validation && !validateDefaults(options, defaults, validation)) {
                /*
                 * The single argument does not match validation assuming this
                 * is an argument list as apposed to an options object. So at
                 * this point lets assume that the first argument was the
                 * options object at this point.
                 */
                options = first;
            } else if (isProbablyJSON(first) && (!validation || validateDefaults(first, defaults, validation))) {
                /*
                 * This situation is a little delicate. The caller has provided
                 * an argument list with only one argument, it matched
                 * validation, but the first argument could also be a JSON which
                 * matches the options object.
                 * 
                 * So which do we return? It could be either the first argument
                 * is a JSON options object, or it could be the first argument
                 * in the list with everything else set to null.
                 * 
                 * For consistency we will just throw an error because the
                 * caller should not have an argument list with validation that
                 * allows this sort of ambiguous situation.
                 */
                throw new Error("configArgs called with one argument, but the validation was not strict enough. " + "Make sure to add at some validation");
            }
        }

        return new Config(options, defaults, validation);
    }

    /**
     * This function will recusively validate the given value against a type.
     * 
     * @param {*} value The value to test
     * @param {*} type The type to test against
     * @param {Array=} errors An optional array to append errors to
     * @return {boolean} If the given value matches the type
     */
    Config.validate = util.validate = function(value, type, errors) {
        var result = false;
        switch (typeof type) {
        case 'string':
            switch (type) {
            case '*':
                result = validateWildcard(value, errors);
                break;
            case 'string':
            case 'number':
            case 'object':
            case 'undefined':
            case 'boolean':
            case 'function':
                result = validateType(value, type, errors);
                break;
            default:
                /*
                 * This would be rather strange for the user to provide a string
                 * in the validation (that didn't match one the standard cases).
                 * But this will be interpreted as though you are specifying
                 * that the only valid value is this particular string.
                 */
                result = validateExact(value, type, errors);
                break;
            }
            break;
        case 'object':
            switch (true) {
            case type === null:
                result = validateUndefined(value, errors);
                break;
            case type instanceof ValidatorType:
                result = type.validate(value, errors);
                break;
            case Array.isArray(type):
                result = validatePossibilities(value, type, errors);
                break;
            default:
                result = validateObject(value, type, errors);
                break;
            }
            break;
        case 'function':
            result = validateConstructor(value, type, errors);
            break;
        case 'undefined':
            result = validateUndefined(value, errors);
            break;
        default:
            /*
             * This would be rather strange for the user to provide a number or
             * boolean in the validation. But this will be interpreted as though
             * you are specifying that the only valid value is this one value.
             */
            result = validateExact(value, type, errors);
            break;
        }
        return result;
    }

    /**
     * You can use this function to define validation for the objects inside of
     * an array. This is different than providing an array of types, in which
     * the value can match any of the validations defined by the types in the
     * array.
     * 
     * Here is an example:
     * 
     * <pre>
     * Config(options, null, {numberList: Config.arrayType('number')}
     * </pre>
     * 
     * The above code will validate the options to ensure that the numberList
     * attribute is an array, and that every value inside that array is a
     * number.
     * 
     * @param {*} subType Every element in the array must match this type
     * @param {number=} minCount The array must have at least this many
     *            elements, 0 by default.
     * @return {ArrayType} An object to use as the value in the validation
     *         object.
     */
    Config.arrayType = function(subType, minCount) {
        return new ArrayType(subType, minCount);
    }

    /**
     * All conditions must be satisfied.
     * 
     * @param {...}
     * @return {AndType}
     */
    Config.and = function() {
        return new AndType(arguments);
    }

    /**
     * Value must be a constructor which extends the given class.
     * 
     * @param {Class} clazz
     * @return {ClassType}
     */
    Config.classType = function(clazz) {
        return new ClassType(clazz);
    }

    /**
     * You can use this function to define validation for an object that must be
     * one of these exact values.
     * 
     * Here is an example:
     * 
     * <pre>
     * Config(options, null, {type: Config.enumType('small','medium','large')})
     * 
     * @param {...} values
     * @return {EnumType}
     */
    Config.enumType = function(values) {
        return new EnumType(arguments);
    }

    /**
     * You can use this to check if the object is an HTMLElement. Optionally you
     * can specify a node name to check if that html element is a particular
     * tag. Don't worry about the case of nodeNode, this will capitalize it for
     * you.
     * 
     * @param {nodeName=} Optional node name i.e. "div" or "table"
     * @return {Object}
     */
    Config.htmlElementType = function(nodeName) {
        var result = {
            nodeType : 1
        };
        if (typeof nodeName == 'string') {
            result.nodeName = nodeName.toUpperCase();
        }
        return result;
    }

    /**
     * You can define that this attribute must be a string that matches the
     * given regex.
     * 
     * @param {RegExp|string} regex
     * @return {Config.ValidatorType}
     */
    Config.regexType = function(regex) {
        return new RegexType(regex);
    }

    /**
     * You can use the ui5 data type.
     * 
     * @param {String} sDataType
     * @return {Config.ValidatorType}
     */
    Config.dataType = function(sDataType) {
        if (window.jQuery && jQuery.sap) {
            jQuery.sap.require('sap.ui.base.DataType');
            jQuery.sap.declare(sDataType);
            var oType = sap.ui.base.DataType.getType(sDataType);
            if (oType) {
                function DataTypeValidator() {
                }
                DataTypeValidator.prototype = ValidatorType.prototype;
                var oValidator = new DataTypeValidator();
                oValidator.validate = function(val) {
                    return !oType.isValid || oType.isValid(val);
                };
                return oValidator;
            }
        }
        throw new Error(sDataType + ' is not a defined type');
    }

    /**
     * You can create a simple data type using the config validation.
     * 
     * @param {String} sDataType The data type
     * @param {Object} oValidation The validation to use
     * @return {Object} The data type object
     */
    Config.createDataType = function(sDataType, oValidation) {
        if (window.jQuery && jQuery.sap) {
            jQuery.sap.require('sap.ui.base.DataType');
            jQuery.sap.declare(sDataType);
            var oType = sap.ui.base.DataType.createType(sDataType, {
                isValid : function(val) {
                    return util.validate(val, oValidation);
                }
            });
            jQuery.sap.setObject(sDataType, oType);
            return oType;
        }
        throw new Error('ui5 not found');
    }

    /**
     * Create an enum type.
     * 
     * @param {String} sDataType
     * @param {Object} oValues
     */
    Config.createEnum = function(sDataType, oValues) {
        if (window.jQuery && jQuery.sap) {
            jQuery.sap.declare(sDataType);
            jQuery.sap.require('sap.ui.base.DataType')
            sap.ui.base.DataType.createType(sDataType, {
                isValid : function(val) {
                    return typeof oValues[val] != 'undefined';
                }
            });
            jQuery.sap.setObject(sDataType, oValues);
            return oValues;
        }
        throw new Error('ui5 not found');
    }

    /**
     * @inner
     * @param {Object} options
     * @param {Object=} defaults
     * @returns {Object}
     */
    function applyDefaults(options, defaults) {
        var config = set({}, options || {});
        if (defaults) {
            for ( var attribute in defaults) {
                if (!options || typeof options[attribute] == 'undefined') {
                    config[attribute] = defaults[attribute];
                }
            }
        }
        return config;
    }

    /**
     * @constructor
     * @lends Config.ValidatorType
     */
    function ValidatorType() {
        throw new Error('Do not directly instantiate.');
    }

    /**
     * The validator must have this function to validate the incoming value.
     * 
     * @param {*} value The incoming value
     * @param {Array=} errors Push specific errors to this array
     */
    ValidatorType.prototype.validate = function(value, errors) {
        throw new Error("A validator must implement the validate function!");
    }

    Config.ValidatorType = ValidatorType;

    /**
     * Determine if this object is really a JSON object or not. There is no
     * fool-proof way to do this, so we will just eliminate the most common
     * things. That is why this function is named with the word "probably".
     * 
     * @inner
     * @param {Object} obj
     * @return {boolean}
     */
    function isProbablyJSON(obj) {
        if (typeof obj == 'object' && !Array.isArray(obj)) {
            /*
             * This is a simple array of types that we know are not simple JSON
             * objects. If the object is not an instance of any of these, then
             * we'll just assume it's a simple JSON.
             */
            var notJsonTypes = [ Date ];
            for (var idx = 0; idx < notJsonTypes.length; idx++) {
                if (obj instanceof notJsonTypes[idx]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * This will apply defaults, and call validate, but it will return the valid
     * flag instead of throwing an error. The options object is not modified.
     * 
     * @inner
     * @param {Object} options
     * @param {Object=} defaults
     * @param {Object=} validation
     */
    function validateDefaults(options, defaults, validation) {
        return Config.validate(applyDefaults(options, defaults), validation);
    }

    /**
     * WARNING: This function is recursive.
     * 
     * @inner
     * @param {*} value
     * @param {Array} array
     * @param {Array=} errors
     * @return {boolean}
     */
    function validatePossibilities(value, array, errors) {
        var result = false;
        for (var idx = 0; idx < array.length; idx++) {
            if (Config.validate(value, array[idx], errors)) {
                result = true;
            }
        }
        return result;
    }

    /**
     * WARNING: This function is recursive.
     * 
     * @inner
     * @param {*} value
     * @param {Object} object
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateObject(value, object, errors) {
        var result = true;
        if (typeof value == 'object' && value !== null) {
            for ( var attribute in object) {
                var subErrors = errors && [];
                if (!Config.validate(value[attribute], object[attribute], subErrors)) {
                    result = false;
                    errors && subErrors.forEach(function(se) {
                        errors.push([ '[Invalid Object Attribute] Attribute: ', attribute, ', Object: ', value, ': ' ].concat(se));
                    });
                }
            }
        } else {
            result = false;
            errors && errors.push([ 'Invalid object, expected: A non-null object, found: ', value ]);
        }
        return result;
    }

    /**
     * @inner
     * @param {*} value
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateUndefined(value, errors) {
        if (value === null || value === undefined) {
            return true;
        } else {
            errors && errors.push([ 'Invalid undefined, expected either null or undefined, found: ', value ]);
            return false;
        }
    }

    /**
     * @inner
     * @param {*} value
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateWildcard(value, errors) {
        if (value !== null && value !== undefined) {
            return true;
        } else {
            errors && errors.push([ 'Invalid required value, expected anything not null or undefined, found: ', value ]);
            return false;
        }
    }

    /**
     * @inner
     * @param {*} value
     * @param {string} type
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateType(value, type, errors) {
        if (typeof value === type) {
            return true;
        } else {
            errors && errors.push([ 'Invalid type, expected: ', type, ', found: ', typeof value, ', value: ', value ]);
            return false;
        }
    }

    /**
     * @inner
     * @param {*} value
     * @param {function} constructor
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateConstructor(value, constructor, errors) {
        if (value instanceof constructor) {
            return true;
        } else {
            errors && errors.push([ 'Invalid value with wrong type, expected an object of type: ', constructor.name, ', but found this value: ', value ]);
        }
    }

    /**
     * @inner
     * @param {*} value
     * @param {*} type
     * @param {Array=} errors
     * @return {boolean}
     */
    function validateExact(value, type, errors) {
        var result = value === type;
        if (!result) {
            errors && errors.push([ 'Invalid exact, expected: ', type, ', value: ', value ]);
        }
        return result;
    }

    /**
     * @inner
     * @constructor
     * @extends ValidatorType
     * @param {*} subType
     * @param {number=} minCount
     */
    function ArrayType(subType, minCount) {
        this.subType = subType;
        this.minCount = minCount || 0;
    }

    extend(ArrayType, ValidatorType, /** @lends ArrayType.prototype */
    {
        /**
         * @overrides
         */
        validate : function(value, errors) {
            var result = Array.isArray(value);
            if (result) {
                result = value.length >= this.minCount;
                if (result) {
                    if (this.subType !== undefined) {
                        value.forEach(function(el, idx) {
                            var subErrors = errors && [];
                            if (!Config.validate(el, this.subType, subErrors)) {
                                result = false;
                                errors && errors.push([ 'Invalid array element at position: ', idx, '.' ]);
                                errors && subErrors.forEach(function(se) {
                                    errors.push([ '[Array Element Error] ' ].concat(se));
                                });
                            }
                        }, this);
                    }
                } else {
                    errors && errors.push([ 'Invalid array, expected: at least ', this.minCount, ' item(s), found: ', value.length, ' item(s)' ])
                }
            } else {
                errors && errors.push([ 'Invalid array, expected: array, found: ', value ]);
            }
            return result;
        }
    });

    /**
     * @inner
     * @constructor
     * @param {arguments} values The arguments passed to Config.arrayType
     * @extends ValidatorType
     */
    function EnumType(values) {
        this.values = [];
        for (var idx = 0; idx < values.length; idx++) {
            this.values.push(values[idx]);
        }
    }

    extend(EnumType, ValidatorType, /** @lends EnumType.prototype */
    {
        /**
         * @overrides
         */
        validate : function(value, errors) {
            var result = false;
            for (var idx = 0; idx < this.values.length; idx++) {
                if (this.values[idx] === value) {
                    result = true;
                    break;
                }
            }
            if (!result) {
                errors && errors.push([ 'Invalid enum, expected: one of ', this.values, ', found: ', value ]);
            }
            return result;
        }
    });

    /**
     * @inner
     * @constructor
     * @extends ValidatorType
     * @param {RegExp|string} regex
     */
    function RegexType(regex) {
        if (typeof regex == 'string') {
            this._regex = new RegExp(regex);
        } else if (regex instanceof RegExp) {
            this._regex = regex;
        } else {
            throw new Error("RegexType: you must pass a string or a RegExp object");
        }
    }

    extend(RegexType, ValidatorType, /** @lends RegexType.prototype */
    {
        /**
         * @overrides
         */
        validate : function(value, errors) {
            var valid = false;
            if (typeof value == 'string') {
                valid = this._regex.test(value);
                if (!valid) {
                    errors && errors.push([ 'Invalid regex value, expected: matches ', this._regex, ', found: ', value ]);
                }
            } else {
                errors && errors.push([ 'Invalid regex value, expected: a string, found: ', value ]);
            }
            return valid;
        }
    });

    /**
     * @inner
     * @constructor
     * @extends ValidatorType
     */
    function AndType(args) {
        this._args = Array.prototype.slice.call(args, 0);
    }

    extend(AndType, ValidatorType, /** @lends AndType.prototype */
    {
        validate : function(value, errors) {
            var valid = true;
            for (var i = 0; i < this._args.length; i++) {
                valid = Config.validate(value, this._args[i], errors) && valid;
            }
            return valid;
        }
    });

    /**
     * @inner
     * @constructor
     * @extends ValidatorType
     * @param {Class} clazz
     */
    function ClassType(clazz) {
        this._class = clazz;
    }

    extend(ClassType, ValidatorType, /** @lends ClassType.prototype */
    {
        validate : function(value, errors) {
            var valid = false;
            if (value && value.prototype) {
                function test() {
                }
                test.prototype = value.prototype;
                valid = new test() instanceof this._class;
            }
            if (!valid) {
                errors.push([ 'Invalid constructor, expected constructor extending: ', this._class, ', found: ', value ]);
            }
            return valid;
        }
    });

    /**
     * @inner
     */
    function extend(childClass, parentClass, overrides) {
        function Parent() {
        }
        Parent.prototype = parentClass.prototype;
        var proto = new Parent();
        for ( var name in overrides) {
            proto[name] = overrides[name];
        }
        childClass.prototype = proto;
    }

    /**
     * @inner
     * @param {Object} oObject
     * @param {Object} oOverrides
     */
    function set(oObject, oOverrides) {
        if (window.juic && juic.set) {
            return juic.set(oObject, oOverrides);
        } else if (window.jQuery) {
            return jQuery.extend(oObject, oOverrides);
        } else {
            throw new Error('[Config] Requires jQuery or juic');
        }
    }

    $.sap.setObject('sap.sf.surj.shell.util.Config', Config);
    return Config;
});